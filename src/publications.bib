@article{weiConsolidatingSmartContracts2024,
  title = {Consolidating {{Smart Contracts}} with {{Behavioral Contracts}}},
  author = {Wei, Guannan and Xie, Danning and Zhang, Wuqi and Yuan, Yongwei and Zhang, Zhuo},
  date = {2024-06-20},
  journaltitle = {Proc. ACM Program. Lang.},
  volume = {8},
  pages = {186:965--186:989},
  doi = {10.1145/3656416},
  url = {https://doi.org/10.1145/3656416},
  urldate = {2024-07-09},
  abstract = {Ensuring the reliability of smart contracts is of vital importance due to the wide adoption of smart contract    programs in decentralized financial applications. However, statically checking many rich properties of smart    contract programs can be challenging. On the other hand, dynamic validation approaches have shown promise    for widespread adoption in practice. Nevertheless, as part of the programming environment for smart contracts,    existing dynamic validation approaches have not provided programmers with a notion to clearly articulate    the interface between components, especially for addresses representing opaque contract instances. We argue    that the “design-by-contract” approach should complement the development of smart contract programs.    Unfortunately, there is only limited linguistic support for that in existing smart contract languages.        In this paper, we design a Solidity language extension ConSol that supports behavioral contracts. ConSol    provides programmers with a modular specification and monitoring system for both functional and latent    address behaviors. The key capability of ConSol is to attach specifications to first-class addresses and monitor    violations when invoking these addresses. We evaluate ConSol using 20 real-world cases, demonstrating    its effectiveness in expressing critical conditions and preventing attacks. Additionally, we assess ConSol’s    efficiency and compare gas consumption with manually inserted assertions, showing that our approach    introduces only marginal gas overhead. By separating specifications and implementations using behavioral    contracts, ConSol assists programmers in writing smart contract code that is more robust and readable.},
  issue = {PLDI},
  file = {/home/slark/Zotero/storage/J2RNI2IE/Wei et al. - 2024 - Consolidating Smart Contracts with Behavioral Contracts.pdf}
}

@article{yuanLivePatternMatching2023a,
  title = {Live {{Pattern Matching}} with {{Typed Holes}}},
  author = {Yuan, Yongwei and Guest, Scott and Griffis, Eric and Potter, Hannah and Moon, David and Omar, Cyrus},
  date = {2023-04-06},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  shortjournal = {Proc. ACM Program. Lang.},
  volume = {7},
  pages = {609--635},
  issn = {2475-1421},
  doi = {10.1145/3586048},
  url = {https://dl.acm.org/doi/10.1145/3586048},
  urldate = {2024-10-05},
  abstract = {Several modern programming systems, including GHC Haskell, Agda, Idris, and Hazel, support               typed holes               . Assigning static and, to varying degree, dynamic meaning to programs with holes allows program editors and other tools to offer meaningful feedback and assistance throughout editing, i.e. in a               live               manner. Prior work, however, has considered only holes appearing in expressions and types. This paper considers, from type theoretic and logical first principles, the problem of typed pattern holes. We confront two main difficulties, (1) statically reasoning about exhaustiveness and irredundancy when patterns are not fully known, and (2) live evaluation of expressions containing both pattern and expression holes. In both cases, this requires reasoning conservatively about all possible hole fillings. We develop a typed lambda calculus, Peanut, where reasoning about exhaustiveness and redundancy is mapped to the problem of deriving first order entailments. We equip Peanut with an operational semantics in the style of Hazelnut Live that allows us to evaluate around holes in both expressions and patterns. We mechanize the metatheory of Peanut in Agda and formalize a procedure capable of deciding the necessary entailments. Finally, we scale up and implement these mechanisms within Hazel, a programming environment for a dialect of Elm that automatically inserts holes during editing to provide static and dynamic feedback to the programmer in a maximally live manner, i.e. for every possible editor state. Hazel is the first maximally live environment for a general-purpose functional language.},
  issue = {OOPSLA1},
  langid = {english},
  file = {/home/slark/Zotero/storage/AMZCRVYN/Yuan et al. - 2023 - Live Pattern Matching with Typed Holes.pdf}
}

@article{yuanTraceGuidedInductiveSynthesis2023a,
  title = {Trace-{{Guided Inductive Synthesis}} of {{Recursive Functional Programs}}},
  author = {Yuan, Yongwei and Radhakrishna, Arjun and Samanta, Roopsha},
  date = {2023-06-06},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  shortjournal = {Proc. ACM Program. Lang.},
  volume = {7},
  pages = {860--883},
  issn = {2475-1421},
  doi = {10.1145/3591255},
  url = {https://dl.acm.org/doi/10.1145/3591255},
  urldate = {2024-10-05},
  abstract = {We propose a novel trace-guided approach to tackle the challenges of ambiguity and generalization in synthesis of recursive functional programs from input-output examples. Our approach augments the search space of programs with recursion traces consisting of recursive subcalls of the programs. Our method is based on a new version space algebra (VSA) for succinct representation and efficient manipulation of pairs of recursion traces and programs that are consistent with each other. We have implemented this approach in a tool called SyRup and evaluated it on benchmarks from prior work. Our evaluation demonstrates that SyRup not only requires fewer examples to achieve a certain success rate than existing synthesizers, but is also less sensitive to the quality of the examples.},
  issue = {PLDI},
  langid = {english},
  file = {/home/slark/Zotero/storage/NMAXSNS2/Yuan et al. - 2023 - Trace-Guided Inductive Synthesis of Recursive Functional Programs.pdf}
}
